# Hermes JavaScript Engine - Copilot Development Rules

This document provides comprehensive guidance for GitHub Copilot to understand the Hermes JavaScript Engine codebase structure, patterns, and development practices.

## Project Overview

**Hermes** is a JavaScript engine optimized for fast start-up of React Native apps. It features ahead-of-time static optimization, compact bytecode generation, and efficient runtime execution.

### Key Components
- **JavaScript Engine**: Fast bytecode interpreter with garbage collection
- **Compiler Pipeline**: JavaScript → AST → IR → Bytecode compilation
- **Parser**: High-performance JavaScript/Flow/JSX parser compiled to WASM
- **Tools**: CLI tools for compilation, debugging, and bytecode analysis
- **Runtime**: VM with optimized object representation and built-ins

## Folder-Specific Rules

### `/API/` - Public APIs and Interfaces
**Purpose**: External APIs for integrating Hermes into applications (React Native, etc.)

**Development Rules**:
- **API Stability**: Changes here affect all embedders - maintain backward compatibility
- **JSI Interface**: Use `jsi::Runtime` as the primary abstraction for JS execution
- **Error Handling**: Always use `jsi::JSError` and proper exception handling
- **Memory Management**: Use RAII patterns and smart pointers for resource management
- **Platform Abstraction**: Code must work across iOS, Android, and desktop platforms

**Key Files**:
- `hermes/hermes.h` - Main public API
- `hermes/hermes.cpp` - HermesRuntime implementation
- `jsi/` - JavaScript Interface standard
- `hermes_abi/` - C ABI for language bindings

**Patterns**:
```cpp
// Use jsi::Runtime interface
std::unique_ptr<jsi::Runtime> runtime = hermes::makeHermesRuntime(config);

// Handle exceptions properly
try {
  runtime->global().setProperty(runtime, "foo", value);
} catch (const jsi::JSError& error) {
  // Handle JS exceptions
}
```

### `/lib/VM/` - Virtual Machine Core
**Purpose**: Core runtime engine including interpreter, garbage collector, and built-in objects

**Development Rules**:
- **Performance Critical**: Code here directly affects execution speed
- **Memory Safety**: Use Handle<> for GC-managed objects, avoid raw pointers
- **Threading**: Most VM code is single-threaded, use appropriate guards for shared state
- **Instruction Dispatch**: Use efficient dispatch mechanisms in interpreter
- **GC Integration**: All object allocations must be GC-aware

**Key Subdirectories**:
- `Runtime.cpp` - Main VM runtime implementation
- `Interpreter.cpp` - Bytecode interpreter
- `Operations.cpp` - JavaScript operation implementations
- `JSLib/` - Built-in JavaScript objects (Array, Object, etc.)
- `gcs/` - Garbage collector implementations
- `Debugger/` - Debug support infrastructure

**Patterns**:
```cpp
// Use Handle<> for GC objects
Handle<JSObject> obj = runtime.makeHandle(JSObject::create(runtime));

// Proper error propagation
CallResult<HermesValue> result = doOperation(runtime);
if (LLVM_UNLIKELY(result == ExecutionStatus::EXCEPTION)) {
  return ExecutionStatus::EXCEPTION;
}
```

### `/lib/BCGen/` - Bytecode Generation
**Purpose**: Converts Hermes IR to executable bytecode

**Development Rules**:
- **Bytecode Stability**: Bytecode format changes require version bumps
- **Optimization Aware**: Consider impact on register allocation and instruction selection
- **Instruction Encoding**: Maintain compact bytecode representations
- **Debug Information**: Preserve source mapping for debugging

**Key Components**:
- `HBC/` - Hermes Bytecode format and generation
- `RegAlloc.cpp` - Register allocation
- `BytecodeGenerator.cpp` - IR to bytecode translation

### `/lib/IRGen/` - IR Generation
**Purpose**: Converts JavaScript AST to Hermes intermediate representation

**Development Rules**:
- **ES6+ Support**: Implement latest JavaScript features in IR form
- **Flow Integration**: Handle Flow type annotations and syntax
- **Optimization Preparation**: Generate IR suitable for optimization passes
- **Scope Management**: Properly handle lexical scoping and closures

**Key Files**:
- `ESTreeIRGen.cpp` - Main IR generation from ESTree AST
- `ESTreeIRGen-expr.cpp` - Expression IR generation
- `ESTreeIRGen-stmt.cpp` - Statement IR generation

### `/lib/Parser/` - JavaScript Parser
**Purpose**: Parses JavaScript source code into Abstract Syntax Tree (AST)

**Development Rules**:
- **Standards Compliance**: Follow ECMAScript specification closely
- **Error Recovery**: Provide meaningful error messages with source locations
- **Performance**: Parser is on critical path - optimize for speed
- **Flow Support**: Handle Flow type syntax when enabled
- **JSX Support**: Parse JSX syntax for React compatibility

**Patterns**:
```cpp
// Use proper error reporting
if (!parseExpected(TokenType::LeftParen)) {
  error(lexer_.getCurrentToken().getSourceRange(), "Expected '('");
  return nullptr;
}
```

### `/lib/Optimizer/` - IR Optimization Passes
**Purpose**: Optimizes Hermes IR for better performance

**Development Rules**:
- **Pass Infrastructure**: Use PassManager for all optimizations
- **SSA Form**: Most passes expect SSA form IR
- **Correctness**: Optimizations must preserve semantics exactly
- **Measurement**: Include performance impact analysis for new passes

**Key Directories**:
- `Scalar/` - Scalar optimizations (DCE, constant folding, etc.)
- `PassManager/` - Pass execution framework

### `/tools/` - Command Line Tools
**Purpose**: Developer tools for compilation, debugging, and analysis

**Development Rules**:
- **CLI Consistency**: Use LLVM CommandLine library patterns
- **User Experience**: Provide clear error messages and help text
- **Tool Composition**: Tools should work well together in pipelines
- **Platform Support**: Support Windows, macOS, and Linux

**Key Tools**:
- `hermes/` - Main interpreter and REPL
- `hermesc/` - Standalone compiler
- `hbcdump/` - Bytecode disassembler
- `hdb/` - JavaScript debugger
- `hermes-parser/` - Standalone parser (WASM)

### `/test/` - Integration Tests
**Purpose**: JavaScript test suite for end-to-end validation

**Development Rules**:
- **Comprehensive Coverage**: Test all JavaScript features supported
- **RUN Lines**: Use FileCheck for output validation
- **Cross-platform**: Tests must pass on all supported platforms
- **Performance Tests**: Include benchmarks for performance-critical features

**Test Categories**:
- `hermes/` - Core runtime tests
- `IRGen/` - IR generation tests
- `Parser/` - Parser correctness tests

**Patterns**:
```javascript
// Use CHECK directives for validation
// RUN: %hermes %s | %FileCheck %s
print("Hello");
// CHECK: Hello
```

### `/unittests/` - Unit Tests
**Purpose**: C++ unit tests for individual components

**Development Rules**:
- **GoogleTest**: Use gtest framework consistently
- **Isolated Testing**: Tests should not depend on each other
- **Mock Objects**: Use mocks for complex dependencies
- **Coverage**: Aim for high code coverage on critical paths

### `/include/hermes/` - Public Headers
**Purpose**: Header files defining public APIs and interfaces

**Development Rules**:
- **ABI Stability**: Changes affect binary compatibility
- **Documentation**: Use Doxygen comments for public APIs
- **Minimal Dependencies**: Avoid including unnecessary headers
- **Platform Independence**: Use portable types and constructs

### `/external/` - Third-party Dependencies
**Purpose**: External libraries and dependencies

**Development Rules**:
- **License Compatibility**: Ensure license compatibility with MIT
- **Version Pinning**: Pin to specific versions for reproducibility
- **Minimal Changes**: Avoid modifying third-party code when possible
- **Security**: Keep dependencies updated for security fixes

### `/doc/` - Documentation
**Purpose**: Architecture documentation and developer guides

**Development Rules**:
- **Accuracy**: Keep documentation synchronized with code changes
- **Completeness**: Document all public APIs and major features
- **Examples**: Include practical code examples
- **Architecture**: Maintain high-level architecture documentation

### `/cmake/` - Build System
**Purpose**: CMake configuration and build scripts

**Development Rules**:
- **Cross-platform**: Support Windows, macOS, Linux builds
- **Modularity**: Use clear target dependencies
- **Options**: Provide build options for different use cases
- **Testing**: Integrate test execution with build system

## Language-Specific Guidelines

### C++ Development
- **Standard**: Use C++17 features, avoid newer standards for compatibility
- **Memory Safety**: Prefer RAII, smart pointers, and containers
- **Error Handling**: Use CallResult<> for recoverable errors
- **Performance**: Profile before optimizing, avoid premature optimization
- **Code Style**: Follow LLVM coding standards

### JavaScript Development
- **ES6+**: Support modern JavaScript features
- **Strict Mode**: Default to strict mode semantics
- **Flow Types**: Support Flow type annotations
- **Test Coverage**: Write comprehensive tests for all features

### CMake Best Practices
- **Modern CMake**: Use target-based dependency management
- **Generator Expressions**: Use for conditional compilation
- **Platform Detection**: Handle platform-specific requirements
- **Options**: Provide clear build configuration options

## Testing Guidelines

### Test Categories
1. **Unit Tests**: Test individual C++ components in isolation
2. **Integration Tests**: Test JavaScript execution end-to-end
3. **Performance Tests**: Measure and validate performance characteristics
4. **Regression Tests**: Prevent reintroduction of fixed bugs

### Test Execution
- Use `lit` for JavaScript test execution
- Use `gtest` for C++ unit tests
- Include cross-platform test validation
- Measure code coverage and aim for high coverage

## Performance Considerations

### Critical Performance Paths
1. **Bytecode Execution**: Interpreter main loop
2. **Object Property Access**: Hidden class transitions
3. **Garbage Collection**: Allocation and collection cycles
4. **Function Calls**: Call/return overhead
5. **String Operations**: String concatenation and comparison

### Optimization Guidelines
- **Measure First**: Profile before optimizing
- **Avoid Allocations**: Minimize GC pressure in hot paths
- **Cache Friendly**: Consider memory access patterns
- **Branch Prediction**: Structure code for predictable branches

## Architecture Patterns

### Error Handling
```cpp
// Use CallResult for operations that can fail
CallResult<HermesValue> doOperation(Runtime &runtime) {
  if (someCondition) {
    return runtime.raiseTypeError("Invalid operation");
  }
  return HermesValue::encodeNumberValue(42);
}
```

### Memory Management
```cpp
// Use Handle<> for GC objects
Handle<JSObject> createObject(Runtime &runtime) {
  return runtime.makeHandle(JSObject::create(runtime));
}
```

### Debug Information
- Always preserve source locations for debugging
- Use `SourceLocation` consistently
- Support source maps for optimized code

This comprehensive guide should help Copilot understand the Hermes codebase structure and provide more accurate and contextually appropriate suggestions for development work across all areas of the project.
